//! Chunk management system for loading/unloading chunks dynamically.
//!
//! Handles chunk lifecycle based on player position and render distance.

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::mpsc::{self, Receiver, Sender};
use std::thread;

use glam::Vec3;
use rayon::prelude::*;

use super::block::Block;
use super::chunk::{Chunk, ChunkPos, SECTION_SIZE};
use super::mesh::{ChunkMesh, MeshGenerator};

/// Configuration for chunk management.
#[derive(Debug, Clone)]
pub struct ChunkManagerConfig {
    /// Render distance in chunks (radius around player).
    pub render_distance: i32,
    /// Maximum chunks to generate per frame.
    pub max_chunks_per_frame: usize,
    /// Maximum chunks to unload per frame.
    pub max_unloads_per_frame: usize,
}

impl Default for ChunkManagerConfig {
    fn default() -> Self {
        Self {
            render_distance: 4, // 9x9 chunks = 81 chunks
            max_chunks_per_frame: 4,
            max_unloads_per_frame: 8,
        }
    }
}

/// State of a chunk in the manager.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ChunkState {
    /// Chunk is queued for generation.
    Queued,
    /// Chunk is being generated.
    Generating,
    /// Chunk is loaded and ready.
    Loaded,
    /// Chunk is marked for unloading.
    Unloading,
}

/// A generated chunk ready to be uploaded to GPU.
pub struct GeneratedChunk {
    /// Chunk position.
    pub pos: ChunkPos,
    /// Generated mesh (may be empty for air-only chunks).
    pub mesh: ChunkMesh,
    /// The chunk data (for block queries and modification).
    pub chunk: Chunk,
}

/// Background worker result.
enum WorkerResult {
    /// A chunk was generated.
    ChunkReady(GeneratedChunk),
}

/// Manages chunk loading, generation, and unloading.
pub struct ChunkManager {
    /// Configuration.
    config: ChunkManagerConfig,
    /// Currently loaded chunks and their state.
    chunk_states: HashMap<ChunkPos, ChunkState>,
    /// Actual chunk data for loaded chunks.
    chunk_data: HashMap<ChunkPos, Chunk>,
    /// Queue of chunks to generate.
    generation_queue: VecDeque<ChunkPos>,
    /// Sender for work requests.
    work_sender: Sender<ChunkPos>,
    /// Receiver for completed chunks.
    result_receiver: Receiver<WorkerResult>,
    /// Set of chunks being generated by workers.
    in_progress: HashSet<ChunkPos>,
    /// Chunks that need their mesh rebuilt (after block modification).
    dirty_chunks: HashSet<ChunkPos>,
}

impl ChunkManager {
    /// Creates a new chunk manager with background workers.
    #[must_use]
    pub fn new(config: ChunkManagerConfig) -> Self {
        let (work_sender, work_receiver) = mpsc::channel::<ChunkPos>();
        let (result_sender, result_receiver) = mpsc::channel::<WorkerResult>();

        // Spawn background worker thread
        let _worker = thread::spawn(move || {
            Self::worker_loop(work_receiver, result_sender);
        });

        Self {
            config,
            chunk_states: HashMap::new(),
            chunk_data: HashMap::new(),
            generation_queue: VecDeque::new(),
            work_sender,
            result_receiver,
            in_progress: HashSet::new(),
            dirty_chunks: HashSet::new(),
        }
    }

    /// Worker thread loop - generates chunks in parallel.
    fn worker_loop(receiver: Receiver<ChunkPos>, sender: Sender<WorkerResult>) {
        // Batch chunks for parallel processing
        let mut batch = Vec::new();
        const BATCH_SIZE: usize = 8;

        loop {
            // Try to receive work
            match receiver.recv() {
                Ok(pos) => {
                    batch.push(pos);

                    // Drain any additional queued work
                    while batch.len() < BATCH_SIZE {
                        match receiver.try_recv() {
                            Ok(pos) => batch.push(pos),
                            Err(_) => break,
                        }
                    }

                    // Process batch in parallel
                    let results: Vec<GeneratedChunk> = batch
                        .par_drain(..)
                        .map(|pos| {
                            let chunk = Self::generate_chunk(pos);
                            let generator = MeshGenerator::new(chunk.clone());
                            GeneratedChunk {
                                pos,
                                mesh: generator.generate(),
                                chunk,
                            }
                        })
                        .collect();

                    // Send results back
                    for result in results {
                        if sender.send(WorkerResult::ChunkReady(result)).is_err() {
                            return; // Main thread gone
                        }
                    }
                }
                Err(_) => return, // Channel closed
            }
        }
    }

    /// Generates terrain for a chunk.
    fn generate_chunk(pos: ChunkPos) -> Chunk {
        let mut chunk = Chunk::new(pos);
        let (cx, cz) = (pos.x, pos.z);

        for x in 0..SECTION_SIZE {
            for z in 0..SECTION_SIZE {
                let wx = cx * SECTION_SIZE as i32 + x as i32;
                let wz = cz * SECTION_SIZE as i32 + z as i32;

                // Noise-based height
                let height = 64
                    + ((wx as f32 * 0.05).sin() * 8.0) as usize
                    + ((wz as f32 * 0.07).cos() * 6.0) as usize
                    + (((wx + wz) as f32 * 0.03).sin() * 4.0) as usize;

                // Bedrock
                chunk.set_block(x, 0, z, Block::Bedrock);

                // Stone
                for y in 1..height.saturating_sub(4) {
                    chunk.set_block(x, y, z, Block::Stone);
                }

                // Dirt
                for y in height.saturating_sub(4)..height {
                    chunk.set_block(x, y, z, Block::Dirt);
                }

                // Grass
                if height < 255 {
                    chunk.set_block(x, height, z, Block::Grass);
                }

                // Trees
                if wx % 11 == 0 && wz % 13 == 0 && wx.abs() > 3 && wz.abs() > 3 {
                    let trunk_height = 4 + (wx.abs() % 3) as usize;
                    for ty in 1..=trunk_height {
                        let y = height + ty;
                        if y < 255 {
                            chunk.set_block(x, y, z, Block::Log);
                        }
                    }

                    // Leaves (simple sphere)
                    let top = height + trunk_height;
                    for ly in -2i32..=2 {
                        for lx in -2i32..=2 {
                            for lz in -2i32..=2 {
                                if lx * lx + ly * ly + lz * lz <= 6 {
                                    let bx = x as i32 + lx;
                                    let by = top as i32 + ly;
                                    let bz = z as i32 + lz;

                                    if bx >= 0
                                        && bx < SECTION_SIZE as i32
                                        && by > 0
                                        && by < 255
                                        && bz >= 0
                                        && bz < SECTION_SIZE as i32
                                    {
                                        let block =
                                            chunk.get_block(bx as usize, by as usize, bz as usize);
                                        if block.is_air() {
                                            chunk.set_block(
                                                bx as usize,
                                                by as usize,
                                                bz as usize,
                                                Block::Leaves,
                                            );
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        chunk
    }

    /// Updates chunk loading based on player position.
    /// Returns chunks that need GPU buffer creation and positions to unload.
    pub fn update(&mut self, player_pos: Vec3) -> (Vec<GeneratedChunk>, Vec<ChunkPos>) {
        let player_chunk = ChunkPos::from_world_pos(player_pos.x, player_pos.z);

        // Determine which chunks should be loaded
        let needed = self.calculate_needed_chunks(player_chunk);

        // Queue new chunks for generation
        for pos in &needed {
            if !self.chunk_states.contains_key(pos) {
                self.chunk_states.insert(*pos, ChunkState::Queued);
                self.generation_queue.push_back(*pos);
            }
        }

        // Send work to background thread
        let mut sent = 0;
        while sent < self.config.max_chunks_per_frame {
            if let Some(pos) = self.generation_queue.pop_front() {
                if self.chunk_states.get(&pos) == Some(&ChunkState::Queued) {
                    self.chunk_states.insert(pos, ChunkState::Generating);
                    self.in_progress.insert(pos);
                    let _ = self.work_sender.send(pos);
                    sent += 1;
                }
            } else {
                break;
            }
        }

        // Collect completed chunks
        let mut ready = Vec::new();
        while let Ok(result) = self.result_receiver.try_recv() {
            match result {
                WorkerResult::ChunkReady(generated) => {
                    self.in_progress.remove(&generated.pos);
                    self.chunk_states.insert(generated.pos, ChunkState::Loaded);
                    // Store the chunk data
                    self.chunk_data
                        .insert(generated.pos, generated.chunk.clone());
                    ready.push(generated);
                }
            }
        }

        // Find chunks to unload
        let mut to_unload = Vec::new();
        let chunks_to_check: Vec<_> = self.chunk_states.keys().copied().collect();

        for pos in chunks_to_check {
            if !needed.contains(&pos) && to_unload.len() < self.config.max_unloads_per_frame {
                if self.chunk_states.get(&pos) == Some(&ChunkState::Loaded) {
                    to_unload.push(pos);
                    self.chunk_states.remove(&pos);
                    self.chunk_data.remove(&pos);
                }
            }
        }

        (ready, to_unload)
    }

    /// Calculates which chunks should be loaded based on player position.
    fn calculate_needed_chunks(&self, center: ChunkPos) -> HashSet<ChunkPos> {
        let r = self.config.render_distance;
        let mut needed = HashSet::new();

        for dx in -r..=r {
            for dz in -r..=r {
                // Circular render distance
                if dx * dx + dz * dz <= r * r {
                    needed.insert(ChunkPos::new(center.x + dx, center.z + dz));
                }
            }
        }

        needed
    }

    /// Returns the number of loaded chunks.
    #[must_use]
    pub fn loaded_count(&self) -> usize {
        self.chunk_states
            .values()
            .filter(|&&s| s == ChunkState::Loaded)
            .count()
    }

    /// Returns the number of chunks being generated.
    #[must_use]
    pub fn generating_count(&self) -> usize {
        self.in_progress.len()
    }

    /// Returns the number of queued chunks.
    #[must_use]
    pub fn queued_count(&self) -> usize {
        self.generation_queue.len()
    }

    /// Returns the render distance.
    #[must_use]
    pub fn render_distance(&self) -> i32 {
        self.config.render_distance
    }

    /// Sets the render distance.
    pub fn set_render_distance(&mut self, distance: i32) {
        self.config.render_distance = distance.max(1).min(32);
    }

    /// Gets a block at the given world position.
    /// Returns None if the chunk is not loaded.
    #[must_use]
    pub fn get_block(&self, x: i32, y: i32, z: i32) -> Option<Block> {
        if y < 0 || y >= 256 {
            return None;
        }

        let chunk_pos = ChunkPos::from_world_pos(x as f32, z as f32);
        let chunk = self.chunk_data.get(&chunk_pos)?;

        let local_x = x.rem_euclid(16) as usize;
        let local_z = z.rem_euclid(16) as usize;

        Some(chunk.get_block(local_x, y as usize, local_z))
    }

    /// Sets a block at the given world position.
    /// Returns true if successful, false if chunk not loaded.
    pub fn set_block(&mut self, x: i32, y: i32, z: i32, block: Block) -> bool {
        if y < 0 || y >= 256 {
            return false;
        }

        let chunk_pos = ChunkPos::from_world_pos(x as f32, z as f32);

        if let Some(chunk) = self.chunk_data.get_mut(&chunk_pos) {
            let local_x = x.rem_euclid(16) as usize;
            let local_z = z.rem_euclid(16) as usize;

            chunk.set_block(local_x, y as usize, local_z, block);
            self.dirty_chunks.insert(chunk_pos);
            true
        } else {
            false
        }
    }

    /// Checks if a block at the given position is solid.
    /// Returns false for unloaded chunks.
    #[must_use]
    pub fn is_block_solid(&self, x: i32, y: i32, z: i32) -> bool {
        self.get_block(x, y, z)
            .map(|b| b.is_solid())
            .unwrap_or(false)
    }

    /// Returns and clears the list of dirty chunks that need mesh rebuilding.
    pub fn take_dirty_chunks(&mut self) -> Vec<ChunkPos> {
        self.dirty_chunks.drain().collect()
    }

    /// Rebuilds the mesh for a specific chunk.
    /// Returns the generated chunk if successful.
    #[must_use]
    pub fn rebuild_chunk_mesh(&self, pos: ChunkPos) -> Option<GeneratedChunk> {
        let chunk = self.chunk_data.get(&pos)?;
        let generator = MeshGenerator::new(chunk.clone());
        Some(GeneratedChunk {
            pos,
            mesh: generator.generate(),
            chunk: chunk.clone(),
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn chunk_pos_from_world_pos() {
        // Block at (0, 0) is in chunk (0, 0)
        assert_eq!(ChunkPos::from_world_pos(0.0, 0.0), ChunkPos::new(0, 0));

        // Block at (15, 15) is still in chunk (0, 0)
        assert_eq!(ChunkPos::from_world_pos(15.9, 15.9), ChunkPos::new(0, 0));

        // Block at (16, 0) is in chunk (1, 0)
        assert_eq!(ChunkPos::from_world_pos(16.0, 0.0), ChunkPos::new(1, 0));

        // Negative coordinates
        assert_eq!(ChunkPos::from_world_pos(-1.0, -1.0), ChunkPos::new(-1, -1));
        assert_eq!(
            ChunkPos::from_world_pos(-16.0, -16.0),
            ChunkPos::new(-1, -1)
        );
        assert_eq!(
            ChunkPos::from_world_pos(-17.0, -17.0),
            ChunkPos::new(-2, -2)
        );
    }

    #[test]
    fn calculate_needed_chunks_radius() {
        let manager = ChunkManager::new(ChunkManagerConfig {
            render_distance: 2,
            ..Default::default()
        });

        let center = ChunkPos::new(0, 0);
        let needed = manager.calculate_needed_chunks(center);

        // Should include center
        assert!(needed.contains(&ChunkPos::new(0, 0)));

        // Should include adjacent chunks
        assert!(needed.contains(&ChunkPos::new(1, 0)));
        assert!(needed.contains(&ChunkPos::new(-1, 0)));
        assert!(needed.contains(&ChunkPos::new(0, 1)));
        assert!(needed.contains(&ChunkPos::new(0, -1)));

        // Corners might be excluded (circular distance)
        // (2, 2) has distance sqrt(8) â‰ˆ 2.83 > 2, so excluded
        assert!(!needed.contains(&ChunkPos::new(2, 2)));
    }

    #[test]
    fn config_defaults() {
        let config = ChunkManagerConfig::default();
        assert_eq!(config.render_distance, 4);
        assert_eq!(config.max_chunks_per_frame, 4);
    }

    #[test]
    fn set_render_distance_clamps() {
        let mut manager = ChunkManager::new(ChunkManagerConfig::default());

        manager.set_render_distance(0);
        assert_eq!(manager.render_distance(), 1);

        manager.set_render_distance(100);
        assert_eq!(manager.render_distance(), 32);

        manager.set_render_distance(8);
        assert_eq!(manager.render_distance(), 8);
    }
}
